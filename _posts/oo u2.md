# UNIT 2
## 总体架构图
#### UML 类图
![](image-3.png)
该图为HW7迭代后结果。
当中MainClass是主类，负责创建Input、Tray、Ctrl并启动线程。Input接受三种请求后会将其加入Tray中，并提醒Ctrl进行分派。在HW6后，分派乘客的方式变成影子电梯的模拟。在HW7后加入了Twins类来实现双轿厢电梯的功能。

#### UML协作图：
![](image-1.png)
![](image-2.png)
当中省略了大部分shadow的线程内容。

#### 稳定的内容与易变的内容
比较稳定的内容包括MainClass类，Person类，Input类等等。这些类从HW5起到HW7起主体没有发生过太大变化。
当中最易变的类包括Lift类与Ctrl类。随着HW6对于RECEIVE的要求和新的请求SCHE的增加，Lift类与Ctrl类都发生了巨大的变化。HW7的双轿厢电梯也造成了巨大的影响。

## 同步块的设置和锁的选择
#### HW5:
在这次作业中，由于乘客的请求被严格限制在了单台电梯上，因此整体的锁的设置上，只选择使用了synchronized作为同步块，也就是拿电梯本身当锁。

#### HW6:
建立了tray->ctrl->lift的外部锁的引用方式。即在ctrl中用tray当锁，在lift中用ctrl当锁。这样能避免出现死锁的情况。

#### HW7:
在HW6的基础上，在电梯中内加入了共享对象twins，把其作为了对于双轿厢相关电梯的处理的锁。

## 调度器设计
#### HW5:
使用了自由竞争+LOOK策略。但是由于自己缩写的代码问题，导致与实际上理想的LOOK策略有所差别。在这次作业中，并不存在一个真正意义上的总调度器。

#### HW6:
由于RECEIVE的约束，自由竞争已经不可用。因此创建了一个新类Shadow，每一台电梯都有自己影子。并在Ctrl中创建了一个Dispatch方法，通过调用getShadow来模拟加入请求的情况的耗时，选择耗时最短的电梯加入请求。

#### HW7:
与HW6相比，对电梯的情况进行了细分。分成了：直接可达，不直接可达，间接可达三种情况。直接可达与HW6相同，不直接可达则是会直接不予分配，间接可达则会以用组成一台双轿厢电梯的两台电梯来模拟。

我之所以没有选择调参电梯的方式，是因为考虑到在正确性方面只在于运行的绝对时间，同时由于性能分的计算公式，很难去估计正确的参数，因此很遗憾地没有考虑耗电量的问题。而在优先度的问题上，采取了在处理同一楼层请求时，优先处理高优先度请求的方法（在加入电梯的请求队列时按优先度排列）。

## 双轿厢的同步改造和预防相撞
#### 同步改造
当两台电梯接到UPDATE请求后，ctrl会设置共享对象twins并将其启动，让电梯把所有人在下一次到达的楼层放出。当乘客被清空后，会阻塞自己，并让twins类ready计数器加一。当ready变为2后会开始输出UPDATE-BEGIN信息。并在UPDATE-END后重新激活两台电梯。

#### 预防相撞
在一台电梯有进中转楼层的意图后，会尝试调用twins.tryOccupy()。成功则能进入，否则将被阻塞。同时进入中转楼层后会强制让其在开门后离开中转楼层。这样能很大程度上避免相撞。

## 出现过的bug
#### HW5
强测/互测没有出现bug，也没能在互测中hack。

#### HW6
强测没有出现bug。
在互测中被hack1次：出现了ctrl线程提前终止的情况。初步认为是当input接受到最后的请求并关闭时，此时请求尚未传递到tray类，导致ctrl错误判断了应该终止，导致RTLE。
在互测中hack成功1次：电梯过早移动。

#### HW7
强测中出现了1个bug：SCHE完成过慢。初步认为是设置SCHE不是原子操作，notify时电梯还未收到SCHE导致的。
在互测中被hack1次：出现了冗余输出的问题。
在互测中hack成功2次：电梯过早移动和线程无法正确终止。

## debug方法
由于多线程很难以用传统的单线程分步调试的方法，除了在最开始检查线程能否可以正常运行时可以使用，其他时候都会干扰多线程的正常运行，因此选择用System.out/TimableOutput打印出某些关键信息来进行debug。

## 心得体会
#### 线程安全
在多线程部分，选择合适的锁是很重要的。在本次作业中我没有使用任何的ReentrantLock对象，全部使用的是synchronized自动加锁和释放锁。在我看来，避免死锁最重要的一点是尽量避免两个程序互相使用对面的锁。同时，要正确识别哪些方法是有关线程安全的，对无关线程安全的方法加锁可能会导致一些不可预知的性能导致的WA问题(例如SCHE完成过慢等)。
同时，可以在某些线程的wait方法中添加一个参数，代表自动唤醒的时间，这样可以在某些程度上增强程序的总体鲁棒性，避免出现不可预知的RTLE等问题。

#### 层次化设计
![](image.png)
如图。
在这些类中，继承了Thread类的有Input，Ctrl，Lift与Twins。
总体而言，由于完成这次作业的可用时间比HW1-HW3少了很多，导致我并没有过多考虑层次化设计的内容，这点也可以通过我下面的复杂度分析可以看出：
![](image-4.png)
可以看出Shadow Ctrl Lift的复杂度都较为糟糕。可能的原因包括Lift和Shadow均未拆分出一个Strategy类等。

## 总结
整个U2给我带来的最大感受就是多线程程序运行时的不可预知性。
多线程程序所出现的很多bug是很难以复现的，同时相较于U1而言，更难以用人眼看出输出的正确与否，导致在这个单元对自动化评测机的需求是极为强烈的。然而由于我自己的程序实现能力所限，一直都没有搭建出自动化评测机，自己只完成了数据生成器。因此我感到在缺少大规模测试的情况下，特别是HW7在提交截止前50min才交上中测全过的版本而强测只错了1个WA，这个单元的三次作业能取得这样的成绩已经是命运的馈赠了。
虽然没有实现理论上性能最优的调参电梯，但是实现了影子电梯还是让我感到一些成就感的。
同时自己用python尝试写了个可视化数据生成器，生成数据的强度还算可以，也算是获得了一些额外的收获吧。
抛开分数不谈，我学习了java的基础多线程和确保线程安全的一些方法，了解到了共享对象与死锁等概念，初步掌握了一定的多线程编程方法，这些我都认为是比单纯的分数更有意义的东西。
